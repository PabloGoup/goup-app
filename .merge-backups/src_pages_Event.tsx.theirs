// src/pages/Event.tsx
import React, { useMemo, useState } from "react";
import { FormProvider, useForm, type Resolver } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import toast from "react-hot-toast";
import logo from "@/assets/goup_logo.png";
import { eventSchema } from "@/lib/schemas";
import { useNavigate } from "react-router-dom";
import { useAuth } from "@/auth/AuthContext";

import {
  RHFInput,
  RHFTextarea,
  RHFSelect,
  RHFCheckboxGroup,
  RHFFile,
} from "@/components/form/control";

import {
  Firestore,
  collection,
  doc,
  setDoc,
} from "firebase/firestore";
import { db as firebaseDb } from "@/lib/firebase";
import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "firebase/storage";

// ★ Venta de tickets + venue
import NewVenueModal from "@/components/venues/NewVenueModal";
import TicketTypesEditor from "@/components/tickets/TicketsEditor";
import type { TicketTypeDraft } from "@/types/commerce";
import { LineupFields } from "@/components/form/LineupFields";
import VenueCombo from "@/components/venues/VenueComboBox";

/* -------------------- Tipos y schema extendido -------------------- */
// Campos extra del form (además del eventSchema existente)
const extraSchema = z.object({
  clubId: z.string().min(1, "Debes seleccionar una localidad"),
  venderTickets: z.boolean().default(false),
  perUserLimit: z
    .number({ invalid_type_error: "Tope inválido" })
    .int()
    .nonnegative()
    .or(
      z
        .string()
        .transform((v) => (v === "" ? 0 : Number(v)))
        .refine((n) => Number.isFinite(n) && n >= 0, "Tope inválido")
    ),
  ventaAbre: z.string().optional().or(z.literal("")),
  ventaCierra: z.string().optional().or(z.literal("")),
  // ← OBLIGATORIA
  fechaFin: z.string().min(1, "Debes indicar la fecha de término"),
});

type ExtraSaleFields = z.infer<typeof extraSchema>;
export type EventFormValues = z.infer<typeof eventSchema> & ExtraSaleFields;

const resolver = zodResolver(
  // combinamos tu schema + el extra
  (eventSchema as unknown as z.ZodTypeAny).and(extraSchema)
) as unknown as Resolver<EventFormValues>;

/* -------------------- Defaults -------------------- */
const defaultValues: EventFormValues = {
  // del eventSchema
  nombre: "",
  tipo: "",
  fecha: "",
  horaInicio: "",
  horaCierre: "",
  capacidad: "",
  presupuesto: "",
  promotor: "",
  telefono: "",
  email: "",
  desc: "",
  generos: [],
  flyer: null,
  imgSec: null,
  edad: 18 as any, // tu schema lo transforma a number
  tieneVip: "",
  vip: "",
  reservas: "No" as any,
  tieneLineup: "No" as any,
  cantidadDJs: "",
  djs: [],
  dress_code: "",
  generosOtro: "",

  // extras
  clubId: "",
  venderTickets: false,
  perUserLimit: 2,
  ventaAbre: "",
  ventaCierra: "",
  fechaFin: "",
};

/* -------------------- Utils -------------------- */
const asBool = (v: unknown): boolean => {
  if (typeof v === "boolean") return v;
  if (v == null) return false;
  const s = String(v).toLowerCase();
  return s === "si" || s === "sí" || s === "true" || s === "1";
};
const asInt = (v: unknown, fallback = 0): number => {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
};
const vipToCount = (v: unknown): number => {
  const s = String(v ?? "");
  if (s.toLowerCase() === "no" || s === "" || s === "0") return 0;
  if (s.toLowerCase().includes("más de")) return 6;
  const n = Number(s);
  return Number.isFinite(n) ? n : 0;
};
const vipToBool = (v: unknown): boolean => vipToCount(v) > 0;

function combineDateTime(dateStr?: string, timeStr?: string): Date | null {
  if (!dateStr || !timeStr) return null;
  const d = new Date(`${dateStr}T${timeStr}:00`);
  return isNaN(d.getTime()) ? null : d;
}

/* -------------------- UI helpers -------------------- */
function Section({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <section className="space-y-4">
      <div className="flex items-center gap-3">
        <h2 className="text-xl md:text-2xl font-extrabold tracking-tight text-[#cbb3ff]">
          {title}
        </h2>
        <div className="h-px flex-1 bg-white/10" />
      </div>
      <div className="bg-white/[0.03] rounded-xl border /10 p-5 md:p-6 shadow-sm">
        {children}
      </div>
    </section>
  );
}

function LoadingButton({
  loading,
  children,
  className = "",
  ...rest
}: React.ButtonHTMLAttributes<HTMLButtonElement> & { loading?: boolean }) {
  return (
    <button
      className={`inline-flex items-center justify-center rounded-md px-5 py-2.5 text-sm font-semibold transition disabled:opacity-50 bg-[#FE8B02] hover:bg-[#7b1fe0] ${className}`}
      disabled={loading}
      {...rest}
    >
      {loading ? "…" : children}
    </button>
  );
}

function SuccessModal({
  open,
  title,
  subtitle,
  onClose,
}: {
  open: boolean;
  title: string;
  subtitle?: string;
  onClose: () => void;
}) {
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 grid place-items-center bg-black/60 backdrop-blur-sm">
      <div className="max-w-md rounded-xl bg-neutral-900 p-6 text-center shadow-lg border /10">
        <h2 className="mb-2 text-2xl font-semibold text-green-400">{title}</h2>
        {subtitle && <p className="/70">{subtitle}</p>}
        <button
          className="mt-6 rounded bg-[#FE8B02] px-4 py-2 text-sm font-medium hover:bg-[#7b1fe0]"
          onClick={onClose}
        >
          Cerrar
        </button>
      </div>
    </div>
  );
}

/* -------------------- Página principal -------------------- */
export default function EventPage() {
  return <EventFormSinglePage />;
}

function EventFormSinglePage() {
  const methods = useForm<EventFormValues>({
    resolver,
    defaultValues,
    mode: "onChange",
  });

  const { user } = useAuth();
  const navigate = useNavigate();

  const [sent, setSent] = useState(false);
  const [generosOtro, setGenerosOtro] = useState("");
  const [newVenueOpen, setNewVenueOpen] = useState(false);
  const [ticketTypes, setTicketTypes] = useState<TicketTypeDraft[]>([]);

  const venderTickets = methods.watch("venderTickets");
  const perUserLimit = methods.watch("perUserLimit");

  /* -------- VALIDACIONES cruzadas antes de guardar -------- */
  const validateCross = useMemo(
    () => (data: EventFormValues): { ok: boolean; msg?: string } => {
      // fechaFin ahora es requerida por schema, pero validamos lógico
      const start = combineDateTime(data.fecha, data.horaInicio);
      const end = combineDateTime(data.fechaFin, data.horaCierre);

      if (!start || !end) return { ok: true };

      if (end.getTime() < start.getTime()) {
        return { ok: false, msg: "La fecha/hora de fin no puede ser anterior al inicio." };
      }

      if (data.ventaAbre || data.ventaCierra) {
        const ventaAbre = data.ventaAbre ? new Date(data.ventaAbre) : null;
        const ventaCierra = data.ventaCierra ? new Date(data.ventaCierra) : null;
        if (ventaAbre && ventaCierra && ventaCierra.getTime() < ventaAbre.getTime()) {
          return { ok: false, msg: "La venta cierra no puede ser anterior a la venta abre." };
        }
        if (ventaCierra && start && ventaCierra.getTime() > start.getTime()) {
          return { ok: false, msg: "La venta debe cerrar antes de que comience el evento." };
        }
      }

      return { ok: true };
    },
    []
  );

  /* -------- SUBMIT -------- */
  const onSubmit = methods.handleSubmit(async (data) => {
    if (!user?.uid) {
      toast.error("Debes iniciar sesión");
      return;
    }

    const cross = validateCross(data);
    if (!cross.ok) {
      toast.error(cross.msg || "Revisa las fechas del evento y ventas.");
      return;
    }

    try {
      const upload = async (file: File | null, folder: string) => {
        if (!file) return null;
        const storage = getStorage();
        const ext = file.name.split(".").pop() || "jpg";
        const path = `Eventos/${user.uid}/${folder}/${Date.now()}.${ext}`;
        const ref = storageRef(storage, path);
        await uploadBytes(ref, file);
        return getDownloadURL(ref);
      };

      const flyerUrl = await upload(data.flyer as File | null, "flyer");
      const imgSecUrl = await upload(data.imgSec as File | null, "imgSec");

      const cleanedDJs = (data.djs || [])
        .map((dj) => (dj ?? "").toString().trim())
        .filter(Boolean);

      const generosFinal =
        (data as any).generos?.includes("Otros") && generosOtro.trim()
          ? [...(data as any).generos.filter((g: string) => g !== "Otros"), generosOtro.trim()]
          : (data as any).generos || [];

      // Colección correcta: "evento"
      const evCol = collection(firebaseDb as Firestore, "evento");
      const evRef = doc(evCol);

      const start = combineDateTime(data.fecha, data.horaInicio);
      const end = combineDateTime(data.fechaFin, data.horaCierre);

      const payload = {
        uid_usersWeb: `/usersWeb/${user.uid}`, // ¡clave correcta!
        nombre: data.nombre,
        tipo: data.tipo,
        fechaInicio: start ? start.toISOString() : null,
        fechaFin: end ? end.toISOString() : null,
        clubId: data.clubId,
        capacidad: data.capacidad,
        presupuesto: data.presupuesto,
        promotor: data.promotor,
        telefono: data.telefono,
        email: data.email,
        descripcion: data.desc,
        generos: generosFinal,
        edad: asInt(data.edad, 18),
        dress_code: data.dress_code,
        tieneVip: vipToBool(data.tieneVip),
        cantidadZonasVip: vipToCount(data.tieneVip),
        aceptaReservas: asBool(data.reservas),
        tieneLineup: asBool(data.tieneLineup),
        cantidadDJs: cleanedDJs.length,
        djs: cleanedDJs,
        flyer: flyerUrl,
        imgSec: imgSecUrl,
        venderTickets: !!data.venderTickets,
        estado: "publicado",
        moneda: "CLP",
        perUserLimit: Math.max(0, Number(data.perUserLimit ?? 0)),
        ventaAbre: data.ventaAbre ? new Date(data.ventaAbre).toISOString() : null,
        ventaCierra: data.ventaCierra ? new Date(data.ventaCierra).toISOString() : null,
        createdAt: new Date().toISOString(),
      };

      await setDoc(evRef, payload);

      if (data.venderTickets) {
        if (ticketTypes.length === 0) {
          toast.error("Agrega al menos un tipo de ticket o desactiva la venta.");
          return;
        }
        const writes = ticketTypes.map((t, i) =>
          setDoc(doc(collection(firebaseDb as Firestore, `evento/${evRef.id}/ticketTypes`)), {
            name: t.name,
            price: Math.max(0, Number(t.price)),
            stockTotal: Math.max(0, Number(t.stockTotal)),
            stockDisponible:
              typeof t.stockDisponible === "number"
                ? Math.max(0, Number(t.stockDisponible))
                : Math.max(0, Number(t.stockTotal)),
            perUserLimit: t.perUserLimit == null ? null : Math.max(0, Number(t.perUserLimit)),
            orden: i + 1,
            activo: !!t.activo,
          })
        );
        await Promise.all(writes);
      }

      toast.success("¡Evento creado con éxito!");
      setSent(true);
      methods.reset(defaultValues);
      setTimeout(() => navigate("/mis-eventos"), 1200);
    } catch (err: any) {
      console.error("Error creando evento:", err);
      toast.error(err.message || "Error inesperado");
    }
  });

  /* -------------------- UI -------------------- */
  const generosMusicales = [
    "Reguetón",
    "Techno",
    "House",
    "Pop",
    "Salsa",
    "Hardstyle",
    "Trance",
    "Hip-Hop",
    "Urbano",
    "Guaracha",
    "Otros",
  ] as const;

  // Estilos para inputs simples
  const fieldCls =
    "w-full bg-white/5  placeholder-white/40 border /10 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-[#FE8B02]";

  return (
    <main className="relative  px-4 py-8">
      <header className="max-w-5xl mx-auto space-y-2 mb-8 text-center">
        <img src={logo} alt="GoUp" className="mx-auto w-28" />
        <h1 className="text-3xl md:text-4xl font-extrabold">
          CREAR <span className="text-[#FE8B02]">EVENTO</span>
        </h1>
        <p className="/70">Organiza la experiencia perfecta con GoUp</p>
      </header>

      <FormProvider {...methods}>
        <form onSubmit={onSubmit} noValidate className="max-w-5xl mx-auto space-y-8">
          {/* Información del Evento */}
          <Section title="Información del evento">
            <div className="grid md:grid-cols-2 gap-4">
              <RHFInput
                name="nombre"
                label="Nombre del Evento *"
                placeholder="Ej: PURPLE NIGHTS • MIDNIGHT VIBES"
              />
              <RHFSelect
                name="tipo"
                label="Tipo de evento *"
                options={["Club", "Festival", "After", "Privado", "Open Air", "Bar"]}
              />
            </div>
          </Section>

          {/* Localidad & Tickets */}
          <Section title="Localidad & tickets">
            <div className="space-y-4">
              <VenueCombo
                value={methods.watch("clubId")}
                onChange={(id) => methods.setValue("clubId", id, { shouldValidate: true })}
                onNewVenue={() => setNewVenueOpen(true)}
              />

              <div className="rounded-lg border /10 bg-black/30 p-4">
                <div className="flex items-center justify-between">
                  <label htmlFor="sell" className="font-medium">
                    Vender tickets
                  </label>
                  <input
                    id="sell"
                    type="checkbox"
                    className="h-5 w-5 accent-[#FE8B02]"
                    checked={!!venderTickets}
                    onChange={(e) => methods.setValue("venderTickets", e.target.checked)}
                  />
                </div>

                {venderTickets && (
                  <div className="mt-4 space-y-4">
                    <div className="grid md:grid-cols-3 gap-4">
                      <div>
                        <label className="text-xs /60">Tope por usuario (global)</label>
                        <input
                          type="number"
                          min={0}
                          className={fieldCls}
                          value={Number(perUserLimit || 0)}
                          onChange={(e) =>
                            methods.setValue("perUserLimit", Math.max(0, Number(e.target.value) || 0), {
                              shouldValidate: true,
                            })
                          }
                        />
                      </div>
                      <RHFInput name="ventaAbre" type="datetime-local" label="Venta abre" />
                      <RHFInput name="ventaCierra" type="datetime-local" label="Venta cierra" />
                    </div>

                    {/* Editor de tipos */}
                    <div className="rounded-lg border /10 bg-white/[0.02] p-3 md:p-4">
                      <TicketTypesEditor
                        value={ticketTypes}
                        onChange={(list) => setTicketTypes(list)}
                        perUserLimitGlobal={
                          typeof perUserLimit === "number" ? perUserLimit : Number(perUserLimit || 0)
                        }
                      />
                    </div>
                  </div>
                )}
              </div>
            </div>
          </Section>

          {/* Fecha & Horario */}
          <Section title="Fecha & horario">
            <div className="grid md:grid-cols-4 gap-4">
              <RHFInput name="fecha" type="date" label="Fecha de inicio *" />
              <RHFInput name="horaInicio" type="time" label="Hora de inicio *" />
              <RHFInput name="fechaFin" type="date" label="Fecha de término *" />
              <RHFInput name="horaCierre" type="time" label="Hora de término *" />
            </div>
            <p className="text-xs /50 mt-2">
              Puedes crear eventos de más de un día: selecciona una fecha de término posterior.
            </p>
          </Section>

          {/* Capacidad */}
          <Section title="Capacidad">
            <RHFSelect
              name="capacidad"
              label="Capacidad esperada *"
              options={["0 a 200", "201 a 500", "501 a 1000", "Más de 1000"]}
            />
          </Section>

          {/* Contacto */}
          <Section title="Contacto del organizador">
            <div className="grid md:grid-cols-3 gap-4">
              <RHFInput name="promotor" label="Promotor *" />
              <RHFInput name="telefono" label="Teléfono *" />
              <RHFInput name="email" type="email" label="Email *" />
            </div>
          </Section>

          {/* Concepto & Experiencia */}
          <Section title="Concepto & experiencia">
            <RHFTextarea name="desc" label="Descripción *" rows={4} />
            <RHFCheckboxGroup name="generos" label="Géneros musicales *" options={[...generosMusicales]} />
            {methods.watch("generos")?.includes("Otros") && (
              <RHFInput
                name="generosOtro"
                label="¿Cuál otro género?"
                value={generosOtro}
                onChange={(e) => setGenerosOtro(e.target.value)}
              />
            )}
          </Section>

          {/* Políticas del evento */}
          <Section title="Políticas del evento">
            <div className="grid md:grid-cols-3 gap-4">
              <RHFSelect
                name="edad"
                label="Edad mínima *"
                options={Array.from({ length: 53 }, (_, i) => `${i + 18}`)}
              />
              <RHFSelect name="dress_code" label="Dress code *" options={["Casual", "Formal", "Semi-formal", "Urbano", "Temático"]} />
              <RHFSelect name="reservas" label="¿Acepta reservas?" options={["Sí", "No"]} />
            </div>
            <div className="grid md:grid-cols-3 gap-4 mt-4">
              <RHFSelect name="tieneVip" label="¿Zonas VIP?" options={["No", "1", "2", "Más de 5"]} />
              <RHFSelect name="tieneLineup" label="¿Tendrá Lineup?" options={["Sí", "No"]} />
              <div className="hidden md:block" />
            </div>
            <div className="mt-2">
              <LineupFields />
            </div>
          </Section>

          {/* Imágenes */}
          <Section title="Imágenes">
            <div className="grid md:grid-cols-2 gap-4">
              <RHFFile name="flyer" label="Flyer del evento" />
              <RHFFile name="imgSec" label="Imagen secundaria" />
            </div>
          </Section>

          <div className="sticky bottom-0 bg-black/60 backdrop-blur border-t /10 py-3">
            <div className="max-w-5xl mx-auto flex justify-end">
              <LoadingButton type="submit">Crear evento</LoadingButton>
            </div>
          </div>
        </form>
      </FormProvider>

      <SuccessModal
        open={sent}
        title="¡Evento creado!"
        subtitle="Ya está publicado. La venta se activará según tu configuración."
        onClose={() => setSent(false)}
      />

      {/* Modal nueva localidad */}
      <NewVenueModal
        open={newVenueOpen}
        onClose={() => setNewVenueOpen(false)}
        onCreated={(clubId, nombre) => {
          methods.setValue("clubId", clubId, { shouldValidate: true });
          toast.success(`Localidad creada: ${nombre}`);
        }}
      />
    </main>
  );
}